
# ビット演算の説明

## この資料について

こちらは`genClaude 3 Opus`を使っての資料です

## ビットとは

コンピューターはデータを0と1の値で表現しています。この0と1の値を**ビット(bit)**と呼びます。ビットは電気の有無で表され、0は電気が無く、1は電気が流れている状態を指します。

2進数表現
複数のビットを組み合わせることで、より大きな値を表現できます。例えば、4ビットなら0から15の値を表現できます。

```js
0000 = 0
0001 = 1
0010 = 2
0011 = 3
...
1111 = 15
```

この2進数表現が、コンピューターがデータを扱う基本的な方法です。

ビット演算子
JavaScriptには、ビットごとの論理演算を行うためのビット演算子が用意されています。

& (ビット単位のAND)
| (ビット単位のOR)
^ (ビット単位のXOR)
~ (ビット単位のNOT)
<< (左シフト)
>> (右シフト、符号維持)
>>> (右シフト、符号なし)
これらの演算子は、整数値の各ビットに対して演算を行います。

例: ビット単位のAND (&)
ビット単位のANDは、2つの対応するビットが両方1の時だけ1になり、それ以外は0になります。

```js
 9 (00001001)
&7 (00000111)
= 1 (00000001)
```

例: ビット単位のOR (|)
ビット単位のORは、2つの対応するビットのどちらか一方が1の時に1になります。

```js
 9 (00001001)
|7 (00000111)
=15 (00001111)
```

例: ビット単位のXOR (^)
ビット単位のXORは、2つの対応するビットが異なる値の時に1になります。

```js
 9 (00001001)
^7 (00000111)
=14 (00001110)
```

例: ビット単位のNOT (~)
ビット単位のNOTは、ビットの値を反転させます(0なら1、1なら0)。

js

```js
~9 (00001001)
  =(11110110)
```

例: 左シフト (<<)
左シフトは、ビットを左に指定したビット数だけシフトします。右側には0が入ります。

```js
9 (00001001) << 2
= 36 (00100100)
```

これは、値に2の累乗を掛けるのと同じ結果になります(9 * 2^2 = 36)。

例: 右シフト (>> および >>>)
右シフトは、ビットを右に指定したビット数だけシフトします。>>は符号ビットを維持しますが、>>>は符号ビットを無視します。

```js
9 (00001001) >> 1
= 4 (00000100)

-9 (11111111111111111111111111110111) >> 1
= -5 (11111111111111111111111111111011)

-9 (11111111111111111111111111110111) >>> 1
= 2147483643 (01111111111111111111111111111011)
```

## ユースケース
ビット演算は、メモリやCPUリソースを効率的に使う必要がある場合に役立ちます。主なユースケースは以下の通りです。

フラグの設定/解除: 整数値の特定のビットを1または0に設定することで、フラグの有無を表現できます。これはファイル権限やデバッグフラグなどで使われます。
ビットマスク: ビットマスクを使って、データ構造の特定のフィールドにアクセスしたり、設定したりできます。この手法はメモリ効率が良いので、グラフィックスやマルチメディアなどのリソース集約型アプリケーションで使われることがあります。
ビットハッキング: ビット操作を使ったアルゴリズムの最適化手法を、ビットハッキングと呼びます。暗号化や圧縮、ハッシュ計算などで使われることがあります。
低レベル操作: OSやデバイスドライバなど、低レベルのプログラミングではビット演算が欠かせません。

## 実践問題

これらの実践問題を解くことで、ビット演算の理解が深まるでしょう。

### 2のn乗を計算する

左シフト演算子を使って、2のn乗を計算する関数を書いてみましょう。例: pow2(3) => 8
ビットの設定と解除: ビット単位のOR、AND、XORを使って、整数のn番目のビットを1または0に設定する関数を書いてみましょう。

### 出現ビットのカウント

ビット単位のANDとシフト演算を使って、整数の中で1が出現する回数を数える関数を書いてみましょう。

### 2つのビットを入れ替える

2つのビット位置を指定して、それらのビットを入れ替える関数を書いてみましょう。
nビット目だけ1にする: 与えられた整数のn番目のビットだけを1にし、他のビットは変更しない関数を書いてみましょう。

### 2の累乗値を求める

与えられた整数より大きい最小の2の累乗値を求める関数を書いてみましょう。

--

## 説明

ref: https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/editorial/?envType=study-plan-v2&envId=leetcode-75

ビット操作についてご存じない方は、まずビット演算について簡単に理解し、基本的なビット演算子を見てみましょう。(クリックで展開 )

ビット操作とは、整数のビットを変更するようにビットを操作することである。
ビット操作の核となるのがビット単位の演算子である：

**NOT (~)**
つまり、現在のビットが00 0 の場合、それを11 1 に変更し、その逆も同様である。

```txt
N = 5 = 101 (in binary)
~N = ~(101) = 010 = 2 (in decimal)
```

**AND (&)**
ビットごとのANDでは、ビットパターンの比較された位置の両方のビットが11 1の場合、結果のビットパターンのビットは11 1となり、そうでない場合は00 0となる。

```txt
A = 5 = 101 (in binary)
B = 1 = 001 (in binary)
A & B = 101 & 001 = 001 = 1 (in decimal)
```

**OR ( | )**
ビットごとのORもビットごとのANDに似ている。ビットパターンの比較された位置の両方のビットが00 0 の場合、結果のビットパターンのビットは00 0 となり、そうでない場合は11 1 となる。

```txt
A = 5 = 101 (in binary)
B = 1 = 001 (in binary)
A | B = 101 | 001 = 101 = 5 (in decimal)
```

**XOR(^)**
ビットごとのXORでは、両方のビットが00 0または11 1の場合、結果は00 0となり、そうでない場合は11 1となる。

```txt
A = 5 = 101 (in binary)
B = 1 = 001 (in binary)
A ^ B = 101 ^ 001 = 100 = 4 (in decimal)
```

**左シフト (<<)**
左シフト演算子は、あるビット数を左にシフトし、最後に00 0 を付加する二項演算子である。1回の左シフトは、ビットパターンに22 2を掛けることに相当する。

```txt
A = 1 = 001 (in binary)
A << 1 = 001 << 1 = 010 = 2 (in decimal)
A << 2 = 001 << 2 = 100 = 4 (in decimal)

B = 5 = 00101 (in binary)
B << 1 = 00101 << 1 = 01010 = 10 (in decimal)
B << 2 = 00101 << 2 = 10100 = 20 (in decimal)
```

**右シフト (>>)**
右シフト演算子は、あるビット数を右にシフトし、左側に00 0 を付加する二項演算子である。1回の右シフトは、ビットパターンを22 2で分割することに相当する。

```txt
A = 4 = 100 (in binary)
A >> 1 = 100 >> 1 = 010 = 2 (in decimal)
A >> 2 = 100 >> 2 = 001 = 1 (in decimal)
A >> 3 = 100 >> 3 = 000 = 0 (in decimal)

B = 5 = 00101 (in binary)
B >> 1 = 00101 >> 1 = 00010 = 2 (in decimal)
```
